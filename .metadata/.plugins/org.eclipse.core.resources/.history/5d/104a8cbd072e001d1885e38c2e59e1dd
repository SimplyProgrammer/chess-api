package org.ugp.api.chess.enginev2;

public class ChessPiece {
	public static final int BLACK = 0;
	public static final int WHITE = 1;
	
	protected int x;
	protected int y;
	protected int color;
	protected boolean hasMoved;
	protected SimpleChessEngine chessBoard;
	protected String type;

	public ChessPiece(SimpleChessEngine board, String type, int color, int xLoc, int yLoc) {
		this.chessBoard = board;
		this.color = color;
		this.x = xLoc;
		this.y = yLoc;
		this.type = type;
		
		chessBoard.placePiece(this, xLoc, yLoc);
	}
	
	@Override
	public String toString() {
		return type;
	}
	
	public boolean canMoveTo(int x, int yPosition) {
		if (chessBoard.isInBounds(x, yPosition)) {
			ChessPiece piece = chessBoard.pieceAt(x, yPosition);
			
			if (piece == null || piece.getColor() != this.color) 
				return true;
		}
		return false;
	}
	
	public void moveTo(int x, int yPosition) {	
		if (chessBoard.pieceAt(x, y) == this)
			chessBoard.removeFromBoard(this);
		this.x = x;
		this.y = yPosition;
		
		ChessPiece target = chessBoard.pieceAt(x, yPosition);
		if (target != null) 
			chessBoard.removeFromBoard(target); //Capture
		
		chessBoard.placePiece(this, x, yPosition);
		hasMoved = true;
	}
	
	public void removePiece() {
		chessBoard.removeFromBoard(this);
		x = y = -1;
	}
	
	public int getX() {
		return x;
	}
	
	public int getY() {
		return y;
	}
	
	public int getColor() {
		return color;
	}

	protected boolean isMovingStraight(int x, int yPosition) {
		int currX = this.getX();
		int currY = this.getY();
		
		int smallerVal;
		int largerVal;
		
		
		if (currX == x) {
			if (currY > yPosition) {
				smallerVal = yPosition;
				largerVal = currY;
			}
			else if (yPosition > currY) {
				smallerVal = currY;
				largerVal = yPosition;
			}
			else 
				return false;
			
			smallerVal++;
			for(; smallerVal < largerVal; smallerVal++) {
				if (chessBoard.pieceAt(currX, smallerVal) != null) {
					return false;
				}
			}
			return true;
		}
		
		
		if (currY == yPosition) {
			if (currX > x) {
				smallerVal = x;
				largerVal = currX;
			}
			else if (x > currX) {
				smallerVal = currX;
				largerVal = x;
			}
			else 
				return false;
			
			smallerVal++;
			for(; smallerVal < largerVal; smallerVal++) {
				if (chessBoard.pieceAt(smallerVal, currY) != null) {
					return false;
				}
			}
			return true;
		}
		
		return false;
	}

	
	protected boolean isMovingDiagonal(int x, int yPosition) {
		int xStart = 0;
		int yStart = 0;
		int xFinish = 1;
		
		int xTotal = Math.abs(x - this.getX());
		int yTotal = Math.abs(yPosition - this.getY());
		
		if (xTotal == yTotal) {
			if (x < this.getX()) {
				xStart = x;
				xFinish = this.getX();
			}
			else if (x > this.getX()) {
				xStart = this.getX();
				xFinish = x;
			}
			else
				return false;
			
			if (yPosition < this.getY()) {
				yStart = yPosition;
			}
			else if (yPosition > this.getY()) {
				yStart = this.getY();
			}
			else
				return false;
			
			xStart++;
			yStart++;
			
			
			for(;xStart < xFinish; xStart++, yStart++) {
				if (chessBoard.pieceAt(xStart, yStart) != null) {
					return false;
				}
			}
			
			return true;
		}
		
		return false;
	}
}
